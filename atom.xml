<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水果芋头</title>
  
  <subtitle>水果芋头的博客</subtitle>
  <link href="https://blog.aalmix.com/atom.xml" rel="self"/>
  
  <link href="https://blog.aalmix.com/"/>
  <updated>2023-03-18T05:41:24.217Z</updated>
  <id>https://blog.aalmix.com/</id>
  
  <author>
    <name>aalmix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 ChatGPT 帮我解决了一个 Nginx 反向代理的问题</title>
    <link href="https://blog.aalmix.com/2023/03/18/chatgpt-help-me-solve-a-nginx-question/"/>
    <id>https://blog.aalmix.com/2023/03/18/chatgpt-help-me-solve-a-nginx-question/</id>
    <published>2023-03-18T10:23:14.000Z</published>
    <updated>2023-03-18T05:41:24.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我有 3 台服务器，1台Web服务器对外提供访问，另外两台服务器 QC1 和 QC2 用于存储不同设备识别后保存的照片。它们的 IP 地址如下：</p><table><thead><tr><th>服务器名称</th><th>IP地址</th></tr></thead><tbody><tr><td>Web服务器</td><td>10.76.2.10</td></tr><tr><td>QC1</td><td>192.168.100.1</td></tr><tr><td>QC2</td><td>192.168.100.2</td></tr></tbody></table><p>前端程序需要根据照片的文件名称把图片显示出来，最开始想到的就是通过 Nginx 进行反向代理来解决这个问题。</p><p>举个例子，照片文件名称是 QC1 开头的，那么就是从 192.168.100.1 服务器上取照片，用户访问 <code>http://10.76.2.10:8029/media/QC1_20220318T131856_1_CT.jpg</code>，实际上访问的是 <code>http://192.168.100.1/media/QC1_20220318T131856_1_CT.jpg</code> 。</p><p>但是由于本人对 Nginx 配置不是很熟悉，通过搜索引擎并一时半会没有找到合适的解决办法，刚好最近 ChatGPT 大红大紫，于是萌生了询问 ChatGPT 来解决这个问题的想法，于是就产生了下面我和 ChatGPT 的对话。</p><h2 id="使用ChatGPT解决"><a href="#使用ChatGPT解决" class="headerlink" title="使用ChatGPT解决"></a>使用ChatGPT解决</h2><p>我向 ChatGPT 说明了我要咨询关于 Nginx 反向代理的问题，并简单介绍了背景。ChatGPT 很快就理解了我的问题，并提供了如下的 Nginx 配置</p><p><img src="https://static.aalmix.com/202303181318732.png" alt="image-20230318113917729"></p><p>接着 ChatGPT 就给出了 nginx 的配置</p><p><img src="https://static.aalmix.com/202303181318673.png" alt="image-20230318114659020"></p><p><img src="https://static.aalmix.com/202303181318441.png" alt="image-20230318114716184"></p><p><img src="https://static.aalmix.com/202303181318954.png" alt="image-20230318114726801"></p><p>如果访问的地址变了，它又会重新修改配置。</p><p><img src="https://static.aalmix.com/202303181318368.png" alt="image-20230318114830619"></p><p>我对它写的 if 语句不清楚是用来做什么的，它也能给出相应的解释。</p><p><img src="https://static.aalmix.com/202303181318796.png" alt="image-20230318115111472"></p><p>这个时候我大概明白了，只要我们拿到 $1 变量，就可以实现根据照片的文件名来反向代理服务器的请求。但是之前它提供的 upstream 配置中并没有QC1和QC2对应的地址，还是继续让 ChatGPT 修改。</p><p><img src="https://static.aalmix.com/202303181318297.png" alt="image-20230318121144872"></p><p><img src="https://static.aalmix.com/202303181318352.png" alt="image-20230318121725378"></p><p>调整好后，让 ChatGPT 重新生成一个完整的 nginx 配置。</p><p><img src="https://static.aalmix.com/202303181318515.png" alt="image-20230318122050247"></p><p>好了，我们把这个配置复制到服务器上，再稍微修改调整一些，重新启动了 Nginx，并使用浏览器测试了一下。</p><p>下面是QC1和QC2服务器上面的两张照片</p><p><img src="https://static.aalmix.com/202303181319176.png" alt="QC1和QC2服务器上的照片"></p><p>我们通过 <a href="http://localhost:8029/">http://localhost:8029</a> （web服务器）分别去访问这两张照片，一切都运行正常，根据照片的文件名，Nginx 正确地将请求转发到了对应的服务器，照片也能够正确地显示出来，🎉🎉🎉！</p><p><img src="https://static.aalmix.com/202303181319596.png" alt="验证访问"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们探讨了如何使用 ChatGPT 来解决一个关于 Nginx 反向代理的问题。通过合理的使用 ChatGPT，我们可以大大提高工作效率，并且还能学习到新的知识点。</p><p>然而，我们也需要注意到一个问题，那就是我们应该降低对 ChatGPT 的期望，将其作为工具来使用，而不是完全相信它。因为它也会出错，我们需要在使用 ChatGPT 的过程中进行反复验证和调整，以确保得到正确的答案。</p><p>因此，我们需要综合考虑 ChatGPT 的优缺点，并将其与我们自己的知识和经验相结合，以获得最佳的解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我有 3 台服务器，1台Web服务器对外提供访问，另外两台服务器 QC1 和 QC2 用于存储不同设备识别后保存的照片。它们的 IP 地址如</summary>
      
    
    
    
    
    <category term="Nginx" scheme="https://blog.aalmix.com/tags/Nginx/"/>
    
    <category term="chatgpt" scheme="https://blog.aalmix.com/tags/chatgpt/"/>
    
  </entry>
  
  <entry>
    <title>美化 Windows Terminal</title>
    <link href="https://blog.aalmix.com/2022/07/30/make-a-beautiful-windows-terminal/"/>
    <id>https://blog.aalmix.com/2022/07/30/make-a-beautiful-windows-terminal/</id>
    <published>2022-07-30T09:19:16.000Z</published>
    <updated>2023-03-18T05:41:24.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.aalmix.com/20220730172459.png" alt="20220730172459"></p><h2 id="安装-PowerShell7"><a href="#安装-PowerShell7" class="headerlink" title="安装 PowerShell7"></a>安装 PowerShell7</h2><p>打开这个<a href="https://docs.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2">链接</a>去下载 PowerShell7 安装包直接运行就完了</p><h2 id="安装-on-my-posh"><a href="#安装-on-my-posh" class="headerlink" title="安装 on-my-posh"></a>安装 <a href="https://ohmyposh.dev/docs/installation/windows">on-my-posh</a></h2><p>执行下面命令 powershell 将安装 on-my-posh 并且应用 on-my-posh 最新主题</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-Expression ((New-Object System.Net.WebClient).<span class="hljs-constructor">DownloadString(&#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">ohmyposh</span>.<span class="hljs-params">dev</span><span class="hljs-operator">/</span><span class="hljs-params">install</span>.<span class="hljs-params">ps1</span>&#x27;)</span>)<br></code></pre></td></tr></table></figure><h2 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h2><p>去 Nerd Fonts 下载 Caskaydia Cove Nerd Font 字体，然后 <code>Ctrl+Shift+,</code> 打开 Windows Terminal 设置，配置 powershell 7 的字体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;colorScheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;One Half Dark&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;guid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PowerShell&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Windows.Terminal.PowershellCore&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;font&quot;</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;face&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CaskaydiaCove NF&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">12</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>先使用 <code>notepad $PROFILE</code> 命令打开 PowerShell 的配置文件，然后在配置文件中添加下面的命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">oh</span><span class="hljs-literal">-my-posh</span> init pwsh <span class="hljs-literal">--config</span> <span class="hljs-string">&quot;<span class="hljs-variable">$env:POSH_THEMES_PATH</span>\zash.omp.json&quot;</span> | <span class="hljs-built_in">Invoke-Expression</span><br></code></pre></td></tr></table></figure><h2 id="安装文件图标库"><a href="#安装文件图标库" class="headerlink" title="安装文件图标库"></a>安装文件图标库</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Install-<span class="hljs-keyword">Module</span> -<span class="hljs-keyword">Name</span> Terminal-Icons -Repository PSGallery<br></code></pre></td></tr></table></figure><p>使用图标需要在 $PROFILE 文件中添加下面命令</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> -<span class="hljs-keyword">Name</span> Terminal-Icons<br></code></pre></td></tr></table></figure><h2 id="设置命令行自动补全和提示"><a href="#设置命令行自动补全和提示" class="headerlink" title="设置命令行自动补全和提示"></a>设置命令行自动补全和提示</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Set</span><span class="hljs-operator">-</span><span class="hljs-variable">PSReadlineKeyHandler</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Key</span> <span class="hljs-built_in">Tab</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Function</span> <span class="hljs-variable">MenuComplete</span><br></code></pre></td></tr></table></figure><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p>将 Git Bash 添加到 Windows Terminal</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">Git Bash命令行 <span class="hljs-string">&quot;C:\Program Files\Git\bin\bash.exe&quot;</span> <span class="hljs-comment">--login -i</span><br>启动目录 %USERPROFILE%<br>图标 <span class="hljs-name">C</span>:\Program Files\Git\mingw64\share\git\git-<span class="hljs-keyword">for</span>-windows.ico<br></code></pre></td></tr></table></figure><hr><p>完整的 powershell 设置如下：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">oh</span><span class="hljs-operator">-</span><span class="hljs-variable">my</span><span class="hljs-operator">-</span><span class="hljs-variable">posh</span> <span class="hljs-variable">init</span> <span class="hljs-variable">pwsh</span> <span class="hljs-operator">|</span> <span class="hljs-variable">Invoke</span><span class="hljs-operator">-</span><span class="hljs-built_in">Expression</span><br><span class="hljs-variable">oh</span><span class="hljs-operator">-</span><span class="hljs-variable">my</span><span class="hljs-operator">-</span><span class="hljs-variable">posh</span> <span class="hljs-variable">init</span> <span class="hljs-variable">pwsh</span> <span class="hljs-operator">--</span><span class="hljs-variable">config</span> <span class="hljs-string">&quot;$env:POSH_THEMES_PATH\powerlevel10k_rainbow.omp.json&quot;</span> <span class="hljs-operator">|</span> <span class="hljs-variable">Invoke</span><span class="hljs-operator">-</span><span class="hljs-built_in">Expression</span><br><br><span class="hljs-built_in">Set</span><span class="hljs-operator">-</span><span class="hljs-variable">PSReadlineKeyHandler</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Key</span> <span class="hljs-built_in">Tab</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Function</span> <span class="hljs-variable">MenuComplete</span><br><span class="hljs-built_in">Import</span><span class="hljs-operator">-</span><span class="hljs-built_in">Module</span> <span class="hljs-operator">-</span><span class="hljs-variable">Name</span> <span class="hljs-variable">Terminal</span><span class="hljs-operator">-</span><span class="hljs-variable">Icons</span><br><span class="hljs-built_in">Import</span><span class="hljs-operator">-</span><span class="hljs-built_in">Module</span> <span class="hljs-variable">posh</span><span class="hljs-operator">-</span><span class="hljs-variable">git</span><br><br></code></pre></td></tr></table></figure><p>参考连接： <a href="https://docs.microsoft.com/zh-cn/windows/terminal/tutorials/custom-prompt-setup">https://docs.microsoft.com/zh-cn/windows/terminal/tutorials/custom-prompt-setup</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.aalmix.com/20220730172459.png&quot; alt=&quot;20220730172459&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-PowerShell7&quot;&gt;&lt;a href=&quot;#安装-PowerShell7&quot; class</summary>
      
    
    
    
    
    <category term="shell" scheme="https://blog.aalmix.com/tags/shell/"/>
    
    <category term="windows terminal" scheme="https://blog.aalmix.com/tags/windows-terminal/"/>
    
  </entry>
  
  <entry>
    <title>使用hugo搭建博客 - 利用 Utterances 搭建博客评论</title>
    <link href="https://blog.aalmix.com/2022/05/25/hugo-blog-use-utterances/"/>
    <id>https://blog.aalmix.com/2022/05/25/hugo-blog-use-utterances/</id>
    <published>2022-05-25T13:51:39.000Z</published>
    <updated>2023-03-18T05:41:24.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.aalmix.com/20220525220957.png" alt="20220525220957"></p><p>Utterances 来搭建博客评论，这是一个很好的博客评论系统，它可以让我们的博客更加简洁，更加美观，更加友好。</p><h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>进入 <a href="https://github.com/apps/utterances">https://github.com/apps/utterances</a> 页面，点击 Configure 按钮，选择 wubh2012.github.io 仓库来将 Utterances 安装到你的 GitHub 仓库中。<br><img src="https://static.aalmix.com/20220525221420.png" alt="20220525221420"></p><p><img src="https://static.aalmix.com/20220525221351.png" alt="20220525221351"></p><p>当有用户发表评论时，Utterances 会自动将评论发送到 GitHub 仓库中。<br><img src="https://static.aalmix.com/20220525221643.png" alt="20220525221643"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.aalmix.com/20220525220957.png&quot; alt=&quot;20220525220957&quot;&gt;&lt;/p&gt;
&lt;p&gt;Utterances 来搭建博客评论，这是一个很好的博客评论系统，它可以让我们的博客更加简洁，更加美观，</summary>
      
    
    
    
    
    <category term="博客" scheme="https://blog.aalmix.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hugo" scheme="https://blog.aalmix.com/tags/hugo/"/>
    
  </entry>
  
  <entry>
    <title>使用hugo搭建博客 - 利用 Github Actions 自动部署网站</title>
    <link href="https://blog.aalmix.com/2022/05/25/hugo-blog-use-git-action-auto-deploy/"/>
    <id>https://blog.aalmix.com/2022/05/25/hugo-blog-use-git-action-auto-deploy/</id>
    <published>2022-05-25T13:50:44.000Z</published>
    <updated>2023-03-18T05:41:24.221Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们每次更新博客都需要重新上传 public 这个目录的文件，步骤比较繁琐，今天给大家分享一下我们可以通过 Github Actions 自动部署的方式来更新博客。</p><h2 id="什么是-GitHub-Action"><a href="#什么是-GitHub-Action" class="headerlink" title="什么是 GitHub Action"></a>什么是 GitHub Action</h2><p>GitHub Actions 是 GitHub 官方推出的持续集成服务。通过 GitHub Actions 可以为你的项目提供持续构建，测试，程序打包和部署一条龙服务。</p><h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><p>进入 wubh2012.github.io 仓库，点击 Actions 选项卡，开始创建一个新的 Actions，按照下面的步骤将操作即可。</p><p><img src="https://static.aalmix.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220526140607.png" alt="微信截图_20220526140607"><br><img src="https://static.aalmix.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220526140646.png" alt="微信截图_20220526140646"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">github</span> <span class="hljs-string">pages</span><br><br><span class="hljs-attr">on:</span> <span class="hljs-comment">#</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&quot;0 0 * * *&quot;</span> <span class="hljs-comment"># every day at midnight</span><br>  <span class="hljs-attr">push:</span> <span class="hljs-comment"># when a new commit is pushed</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-18.04</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">submodules:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Fetch Hugo themes (true OR recursive)</span><br>          <span class="hljs-attr">fetch-depth:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># Fetch all history for .GitInfo and .Lastmod</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Hugo</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-hugo@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">hugo-version:</span> <span class="hljs-string">&quot;0.82.0&quot;</span><br>          <span class="hljs-attr">extended:</span> <span class="hljs-literal">true</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;12.x&quot;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">~/.npm</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.os &#125;&#125;-node-</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">i</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">hugo</span> <span class="hljs-string">--minify</span> <span class="hljs-comment"># 使用hugo构建静态网页</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br>          <span class="hljs-attr">cname:</span> <span class="hljs-string">blog.aalmix.com</span> <span class="hljs-comment"># 为了实现自定义域名，增加了 cname 配置</span><br>          <span class="hljs-attr">user_name:</span> <span class="hljs-string">&quot;github-actions[bot]&quot;</span><br>          <span class="hljs-attr">user_email:</span> <span class="hljs-string">&quot;github-actions[bot]@users.noreply.github.com&quot;</span><br></code></pre></td></tr></table></figure><p>配置好后我们每次推送更新到仓库，都会触发自动构建静态网页，默认放到 <code>gh-pages</code> 分支，可能需要到设置中修改 Github Page 的源<br><img src="https://static.aalmix.com/20220526180758.png" alt="20220526180758"></p><p>而且每天凌晨也会自动部署，这样是不是省事多了 😀 ！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前我们每次更新博客都需要重新上传 public 这个目录的文件，步骤比较繁琐，今天给大家分享一下我们可以通过 Github Actions 自动部署的方式来更新博客。&lt;/p&gt;
&lt;h2 id=&quot;什么是-GitHub-Action&quot;&gt;&lt;a href=&quot;#什么是-GitHub-</summary>
      
    
    
    
    
    <category term="博客" scheme="https://blog.aalmix.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hugo" scheme="https://blog.aalmix.com/tags/hugo/"/>
    
  </entry>
  
  <entry>
    <title>使用hugo搭建博客 - 自定义域名</title>
    <link href="https://blog.aalmix.com/2022/05/25/hugo-blog-custom-domain/"/>
    <id>https://blog.aalmix.com/2022/05/25/hugo-blog-custom-domain/</id>
    <published>2022-05-25T13:40:07.000Z</published>
    <updated>2023-03-18T05:41:24.221Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章当中讲了如何使用 hugo 搭建了我们自己的静态博客并托管到了 github 上，但无法和我们自己的域名进行关联，这个时候我们就需要自定义域名了。</p><p>首先我们需要配置 DNS 解析，以腾讯云为例，在腾讯云的 DNS 解析记录中添加一个 CNAME 记录，主机记录的值为 <code>blog</code>，记录值为<code>wubh2012.github.io</code></p><p><img src="https://static.aalmix.com/20220526132439.png" alt="20220526132439"></p><p>然后在 github page 的 Custom domain 填写记录值 <code>blog.aalmix.com</code></p><p><img src="https://static.aalmix.com/20220525214629.png" alt="20220525214629"></p><p>最后，我们可以使用 <a href="https://blog.aalmix.com/">https://blog.aalmix.com</a> 地址去访问我们的博客了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇文章当中讲了如何使用 hugo 搭建了我们自己的静态博客并托管到了 github 上，但无法和我们自己的域名进行关联，这个时候我们就需要自定义域名了。&lt;/p&gt;
&lt;p&gt;首先我们需要配置 DNS 解析，以腾讯云为例，在腾讯云的 DNS 解析记录中添加一个 CNAME 记</summary>
      
    
    
    
    
    <category term="博客" scheme="https://blog.aalmix.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hugo" scheme="https://blog.aalmix.com/tags/hugo/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 hugo 搭建自己的博客</title>
    <link href="https://blog.aalmix.com/2022/04/12/use-hugo-build-your-blog/"/>
    <id>https://blog.aalmix.com/2022/04/12/use-hugo-build-your-blog/</id>
    <published>2022-04-12T06:13:41.000Z</published>
    <updated>2023-03-18T05:41:24.225Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来讲讲如何使用 Hugo 搭建自己的博客。</p><h2 id="下载-Hugo"><a href="#下载-Hugo" class="headerlink" title="下载 Hugo"></a>下载 Hugo</h2><p>首先我们到 <a href="https://github.com/gohugoio/hugo/releases">Hugo Release</a> 页面根据自己的操作系统版本下载 Hugo，本文以 Windows 为例，我们下载 Windows x64 版本，然后将文件解压到 <code>D:/software/hugo</code> 目录下</p><p><img src="https://static.aalmix.com/20220417210225.png" alt="20220417210225"></p><p><img src="https://static.aalmix.com/20220417210629.png" alt="20220417210629"></p><p>然后配置一下系统的环境变量，打开电脑的高级系统设置，设置系统变量，在 <code>PATH</code>变量后面添加 Hugo 的目录 <code>D:/software/hugo</code>，然后保存，关闭系统设置，然后打开命令行，进入 <code>D:/software/hugo</code> 目录，执行 <code>hugo version</code> 命令验证一下即可，如下图所示：</p><p><img src="https://static.aalmix.com/20220417211154.png" alt="20220417211154"></p><p><img src="https://static.aalmix.com/20220417211401.png" alt="20220417211401"></p><p>配置好环境变量后我们就可以在任意一个目录下执行 <code>hugo</code> 命令了。</p><h2 id="创建博客站点"><a href="#创建博客站点" class="headerlink" title="创建博客站点"></a>创建博客站点</h2><p>我们可以使用 <code>hugo new site myblog</code> 创建一个新的博客站点，然后在 <code>myblog</code> 目录下执行 <code>hugo server</code> 命令，hugo 默认端口使用的是 1313, 我们在浏览器中输入 <code>http://localhost:1313</code> 就可以访问了如下图所示：</p><p><img src="https://static.aalmix.com/20220420211247.png" alt="20220420211247"><br>由于我们目前还没有写任何文章，所以看到的是一个空白的页面。<br><img src="https://static.aalmix.com/20220420211620.png" alt="20220420211620"></p><h3 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h3><p>在 myblog 根目录下，运行下面命令，添加主题 <a href="https://github.com/forecho/hugo-theme-echo">hugo-theme-echo</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">git init <span class="hljs-comment"># 初始化 git</span><br>git submodule add https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/forecho/</span>hugo-theme-echo.git themes/echo<br>cd themes<span class="hljs-regexp">/echo # 进入 themes/</span>echo 目录<br>npm ci <span class="hljs-comment"># 本地开发才需要</span><br></code></pre></td></tr></table></figure><h3 id="修改-hugo-配置"><a href="#修改-hugo-配置" class="headerlink" title="修改 hugo 配置"></a>修改 hugo 配置</h3><p>大家可以根据我的 <a href="https://github.com/wubh2012/wubh2012.github.io/blob/master/config.toml">config.toml</a> 文件进行修改。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">baseUrl</span> = <span class="hljs-string">&quot;https://wubh2012.githuo.io&quot;</span><br><span class="hljs-attr">languageCode</span> = <span class="hljs-string">&quot;en-us&quot;</span><br><span class="hljs-attr">title</span> = <span class="hljs-string">&quot;AALMIX&#x27;s Blog&quot;</span><br><span class="hljs-attr">theme</span> = <span class="hljs-string">&quot;echo&quot;</span><br><span class="hljs-attr">DefaultContentLanguage</span> = <span class="hljs-string">&quot;cn&quot;</span><br><span class="hljs-comment"># 自动检测是否包含中文/日文/韩文，该参数会影响摘要和字数统计功能，建议设置为 true</span><br><span class="hljs-attr">hasCJKLanguage</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment"># 设置页面生成形式，将默认的网站路径/修改成.html</span><br><span class="hljs-attr">uglyURLs</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">googleAnalytics</span> = <span class="hljs-string">&quot;&quot;</span>      <span class="hljs-comment"># UA-XXXXXXXX-X</span><br><span class="hljs-attr">enableRobotsTXT</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">## 评论系统</span><br><span class="hljs-attr">changyanAppid</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># Changyan app id             # 畅言</span><br><span class="hljs-attr">changyanAppkey</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># Changyan app key</span><br><span class="hljs-attr">livereUID</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># LiveRe UID                  # 来必力</span><br><br><span class="hljs-section">[markup.highlight]</span><br><span class="hljs-attr">codeFences</span> = <span class="hljs-literal">true</span> <span class="hljs-comment"># 高亮 markdown 的代码块</span><br><span class="hljs-attr">guessSyntax</span> = <span class="hljs-literal">true</span> <span class="hljs-comment"># 高亮 markdown 中没有标注语言的代码块</span><br><span class="hljs-attr">hl_Lines</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">lineNoStart</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">lineNos</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">lineNumbersInTable</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">noClasses</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">style</span> = <span class="hljs-string">&quot;dracula&quot;</span><br><span class="hljs-attr">tabWidth</span> = <span class="hljs-number">2</span><br><br><span class="hljs-comment"># https://gohugo.io/content-management/urls/#aliases</span><br><span class="hljs-section">[permalinks]</span><br><span class="hljs-attr">posts</span> = <span class="hljs-string">&quot;/:filename&quot;</span><br><br><span class="hljs-section">[outputFormats.RSS]</span><br><span class="hljs-attr">mediatype</span> = <span class="hljs-string">&quot;application/rss&quot;</span><br><span class="hljs-attr">baseName</span> = <span class="hljs-string">&quot;atom&quot;</span><br><br><span class="hljs-section">[services.rss]</span><br><span class="hljs-attr">limit</span> = <span class="hljs-number">20</span><br><br><span class="hljs-section">[author]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;AALMIX&quot;</span><br><span class="hljs-attr">avatar</span> = <span class="hljs-string">&quot;https://avatars.githubusercontent.com/u/22315624?s=400&amp;u=0f4091c87fa6cb1f7ed21d691a5e0bc3eb0b0814&amp;v=4&quot;</span><br><span class="hljs-attr">bio</span> = <span class="hljs-string">&quot; 一名普通的程序员 😀&quot;</span><br><span class="hljs-attr">homepage</span> = <span class="hljs-string">&quot;https://aalmix.com/&quot;</span><br><br><span class="hljs-section">[params]</span><br><span class="hljs-attr">favicon</span> = <span class="hljs-string">&quot;https://avatars.githubusercontent.com/u/22315624?s=460&amp;v=4&quot;</span><br><span class="hljs-attr">keywords</span> = <span class="hljs-string">&quot;AALMIX, 水果芋头,web develoment&quot;</span><br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;AALMIX, aalmix blog, aalmix 独立博客，水果芋头&quot;</span><br><span class="hljs-attr">toc</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">navItems</span> = [<br>  [<span class="hljs-string">&quot;HOME&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>],<br>  [<span class="hljs-string">&quot;ARCHIVE&quot;</span>, <span class="hljs-string">&quot;/posts.html&quot;</span>],<br>  [<span class="hljs-string">&quot;ABOUT&quot;</span>, <span class="hljs-string">&quot;/about.html&quot;</span>],<br>  [<span class="hljs-string">&quot;RSS&quot;</span>, <span class="hljs-string">&quot;/atom.xml&quot;</span>]<br>]<br><span class="hljs-comment"># rss 全文输出</span><br><span class="hljs-attr">rssFullContent</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">uglyURLs</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">busuanzi</span> = <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否使用不蒜子统计站点访问量</span><br><span class="hljs-attr">staticCDNPrefix</span> = <span class="hljs-string">&quot;https://cdn.bootcss.com/font-awesome/5.11.2&quot;</span><br><span class="hljs-attr">extraHead</span> = <span class="hljs-string">&#x27;&lt;script async src=&quot;https://www.googletagmanager.com/gtag/js?id=UA-xxx&quot;&gt;&lt;/script&gt;&#x27;</span><br><span class="hljs-attr">postAds</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment">#profileAds = &#x27;&lt;div class=&quot;bg-white shadow&quot;&gt;&lt;img class=&quot; object-cover w-auto mx-auto mt-6&quot; src=&quot;https://blog-1251237404.cos.ap-guangzhou.myqcloud.com/20190424153337.png&quot; alt=&quot;微信打赏&quot;&gt;&lt;/div&gt;&#x27;</span><br><span class="hljs-attr">notFoundAds</span> = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># 开启版权声明，协议名字和链接都可以换</span><br><span class="hljs-section">[params.cc]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;署名 - 非商业性使用 4.0 国际 (CC BY-NC 4.0)&quot;</span><br><span class="hljs-attr">link</span> = <span class="hljs-string">&quot;https://creativecommons.org/licenses/by-nc/4.0/deed.zh&quot;</span><br><br><span class="hljs-comment"># 文章打赏</span><br><span class="hljs-section">[params.reward]</span><br><span class="hljs-attr">enable</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">title</span> = <span class="hljs-string">&quot;打赏&quot;</span><br><span class="hljs-attr">wechat</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 微信二维码</span><br><span class="hljs-attr">alipay</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 支付宝二维码</span><br><br><span class="hljs-comment">############## 评论系统  start ##############</span><br><br><br><span class="hljs-section">[params.utterances]</span> <span class="hljs-comment"># https://utteranc.es/</span><br><span class="hljs-attr">enable</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">owner</span> = <span class="hljs-string">&quot;wubh2012&quot;</span> <span class="hljs-comment"># Your GitHub ID</span><br><span class="hljs-attr">repo</span> = <span class="hljs-string">&quot;wubh2012.github.io&quot;</span> <span class="hljs-comment"># The repo to store comments</span><br><span class="hljs-attr">theme</span> = <span class="hljs-string">&quot;github-light&quot;</span><br><span class="hljs-attr">issueterm</span> = <span class="hljs-string">&quot;pathname&quot;</span><br><br><span class="hljs-comment">############ 评论系统  end ##############</span><br><span class="hljs-comment">## 社交链接</span><br><span class="hljs-section">[social]</span><br><span class="hljs-attr">github</span> = <span class="hljs-string">&quot;wubh2012&quot;</span><br><span class="hljs-attr">twitter</span> = <span class="hljs-string">&quot;twbh_wubh&quot;</span><br><span class="hljs-attr">cnblogs</span> = <span class="hljs-string">&quot;wubh&quot;</span><br><span class="hljs-attr">rss</span> = <span class="hljs-string">&quot;/atom.xml&quot;</span><br></code></pre></td></tr></table></figure><p>然后我们再运行 <code>hugo server -D</code> 命令，在浏览器中输入 <code>http://localhost:1313</code> 就可以看到我们的新博客了。<br>补上带图片的。</p><h2 id="写下你的第一篇文章"><a href="#写下你的第一篇文章" class="headerlink" title="写下你的第一篇文章"></a>写下你的第一篇文章</h2><p>使用命令 <code>hugo new posts/hello-world.md</code>, 会在 <code>content/posts/</code> 目录下创建一个 hello-world.md 文件，Hugo 允许你使用 yaml，toml 或者 json 语法在你每一篇文章的开头进行设置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-comment"># 常用定义</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">&quot;An Example Post&quot;</span>           <span class="hljs-comment"># 标题</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-04-12T16:01:23+08:00</span>    <span class="hljs-comment"># 创建时间</span><br><span class="hljs-attr">lastmod:</span> <span class="hljs-number">2022-04-12T16:01:23+08:00</span> <span class="hljs-comment"># 最后修改时间</span><br><span class="hljs-attr">draft:</span> <span class="hljs-literal">false</span>                       <span class="hljs-comment"># 是否是草稿？</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">&quot;tag-1&quot;</span>, <span class="hljs-string">&quot;tag-2&quot;</span>, <span class="hljs-string">&quot;tag-3&quot;</span>, <span class="hljs-string">&quot;popular&quot;</span>]  <span class="hljs-comment"># 标签</span><br><span class="hljs-attr">categories:</span> [<span class="hljs-string">&quot;index&quot;</span>]              <span class="hljs-comment"># 分类</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">&quot;wubh2012&quot;</span>                  <span class="hljs-comment"># 作者</span><br><br><span class="hljs-comment"># 用户自定义</span><br><span class="hljs-comment"># 你可以选择 关闭 (false) 或者 打开 (true) 以下选项</span><br><span class="hljs-attr">comment:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment"># 关闭评论</span><br><span class="hljs-attr">toc:</span> <span class="hljs-literal">false</span>       <span class="hljs-comment"># 关闭文章目录</span><br><span class="hljs-attr">reward:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭打赏</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">## Hello World!</span><br></code></pre></td></tr></table></figure><p>然后我们再次运行 <code>hugo serve -D</code> 命令，在浏览器中输入 <code>http://localhost:1313/hello-world.html</code> 就可以看到我们的新文章了。</p><h2 id="发布到-GitHub"><a href="#发布到-GitHub" class="headerlink" title="发布到 GitHub"></a>发布到 GitHub</h2><ol><li>在 Github 创建一个与你账号同名的仓库，以 wubh2012.github.io 为例子</li><li>在仓库中设置启用 GitPage<br><img src="https://static.aalmix.com/20220525212029.png" alt="20220525212029"></li><li>首先使用 <code>hugo -D</code> 构建静态站点，默认会在 <code>public/</code> 目录下生成静态文件，将 public 文件夹的内容上传到仓库中<br><img src="https://static.aalmix.com/20220525212122.png" alt="20220525212122"></li><li>访问 <a href="https://wubh2012.github.io/">https://wubh2012.github.io</a></li></ol><p><img src="https://static.aalmix.com/20220525212203.png" alt="20220525212203"></p><p>大工告成，恭喜你现在有一个自己的博客了！如果博客有更新只要重新上传 public 文件夹即可, 后面会教大家如何使用 GitAction 自动更新部署。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天我们来讲讲如何使用 Hugo 搭建自己的博客。&lt;/p&gt;
&lt;h2 id=&quot;下载-Hugo&quot;&gt;&lt;a href=&quot;#下载-Hugo&quot; class=&quot;headerlink&quot; title=&quot;下载 Hugo&quot;&gt;&lt;/a&gt;下载 Hugo&lt;/h2&gt;&lt;p&gt;首先我们到 &lt;a href=&quot;ht</summary>
      
    
    
    
    
    <category term="博客" scheme="https://blog.aalmix.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hugo" scheme="https://blog.aalmix.com/tags/hugo/"/>
    
  </entry>
  
  <entry>
    <title>Docker 指南</title>
    <link href="https://blog.aalmix.com/2022/04/09/docker-guide/"/>
    <id>https://blog.aalmix.com/2022/04/09/docker-guide/</id>
    <published>2022-04-09T02:37:09.000Z</published>
    <updated>2023-03-18T05:41:24.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-指南"><a href="#Docker-指南" class="headerlink" title="Docker 指南"></a>Docker 指南</h1><p>本文的目的是解释与 Docker 相关的重要概念，以便能够有效的使用 Docker 开发应用程序。</p><h2 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker?"></a>什么是 Docker?</h2><p>Docker 是一个能够在独立的环境中运行应用程序的的工具。</p><p>它可以确保应用程序能在独立的环境下运行，应用程序能够按预期的那样在不同的机器&#x2F;服务器上运行。这样可以确保在本地开发应用程序，部署到服务器环境上也可以运行。对于开发人员来说，Docker 能够在任何计算机上按照预期快速的启动和运行程序，与其他开发人员协作时也不需要关心他们的电脑配置如何。</p><p>在不同的电脑上运行应用程序之所以这么困难，是因为必须先正确的安装应用程序所依赖的软件版本。例如，假如在一台安装了Node.js 12.8 版本的电脑上可以正常运行一个由 Node.js 构建的API项目，换到一台安装了 Node.js 10.18 版本的电脑上可能不一定就能运行起来，因为使用的API可能不一样。其他的应用程序可能也会有同样的问题，比如 python, ruby, php, typescript, mysql 等等。Docker 的出现使得构建容器化的应用程序成为了可能，这些应用程序都自带了依赖项的正确版本，可以在不同电脑上运行。</p><p>Docker 有4种类型的“对象”来创建这些隔离的环境：images(镜像), containers(容器)，volumes(存储卷) 和 network(网络)。我们使用最多的还是 Docker images 和 Docker containers。</p><p>Docker images(镜像)理解为一个包含了操作系统和应用的对象，Docker containers(容器)是用来运行Docker镜像中代码的环境。Docker 镜像可以保存到Docker仓库中心，供其他人下载使用。目前最流行的Docker 仓库是 Docker Hub。</p><p>Docker volumes(存储卷) 用于保存容器所产生的数据，将数据保存到 Docker 存储卷中后，即使 Docker 容器被删除、重新创建、重新启动，数据也不会丢失。Docker volumen支持2个容器共享访问相同的数据，只需要将容器的的存储卷指向相同的位置就可以。</p><p>Docker network(网络) 可以用来隔离容器，可以允许容器之间彼此通信。</p><h2 id="那么虚拟机呢-virtual-machines？"><a href="#那么虚拟机呢-virtual-machines？" class="headerlink" title="那么虚拟机呢 virtual machines？"></a>那么虚拟机呢 virtual machines？</h2><p>经常出现虚拟机(vm)与 Docker 相关的话题，因为它们都用来创建隔离的环境。<br>使用 Docker后，应用程序将在容器的独立环境下运行，这些容器中的每一个都共享同一个电脑上的操作系统内核。另一方面，在虚拟机上运行的应用程序运行在自己的操作系统上，不共享底层内核，虚拟机需要在 hypervisor 帮助下运行和管理要运行的操作系统。</p><p><img src="https://static.aalmix.com/202302272234900.jpeg" alt="Type 1 Hypervisors"></p><p>使用Docker相对于虚拟机来说有压倒性的优势，Docker容器可以在几秒钟到几分钟运行起来，而且是轻量级的（MB 相对于GB的大小），容易配置，并且只使用少量的资源。也许使用虚拟机而不是Docker的唯一原因是，由于担心 Docker 容器在主机操作系统上使用共享内核会产生安全漏洞，因此需要更高级别的隔离。</p><p><img src="https://static.aalmix.com/202303042113903.png" alt="image-20230304211323796"></p><p>Docker 镜像对于虚拟机区别</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 <code>MB</code></td><td>一般为 <code>GB</code></td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="Docker-engine"><a href="#Docker-engine" class="headerlink" title="Docker engine"></a>Docker engine</h2><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>目前安装 Docker 相关依赖的最简单的方法是安装 Docker Desktop。 Docker Desktop 附带了几个与 Docker 相关的工具，包括 Docker Engine、Docker CLI 和 Docker Compose。<br>对于 Mac 和 Windows 用户可以通过下面的链接进行下载安装</p><ul><li>Mac <a href="https://docs.docker.com/docker-for-mac/install/">https://docs.docker.com/docker-for-mac/install/</a></li><li>Windows <a href="https://docs.docker.com/docker-for-windows/install/">https://docs.docker.com/docker-for-windows/install/</a></li></ul><p>安装以后，请确保 Docker Desktop 正在运行。如果 Docker Desktop 正在运行，则意味着 Docker Engine 已启动，并且本文提到的 Docker CLI 命令也能执行。</p><p><img src="https://static.aalmix.com/202302272239849.png" alt="Docker Desktop is running indicator"></p><p>对于 Linux 用户来说并没有 Docker Desktop软件，所以每个组件必须单独安装</p><ul><li><a href="https://docs.docker.com/engine/install/">Docker Engine + CLI </a></li><li><a href="https://docs.docker.com/compose/install/">Docker Compose</a></li></ul><p>在 Linux 系统当中，需要通过下面的命令启动 Docker 的守护进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl start docker<br></code></pre></td></tr></table></figure><p>上面的命令应该可以正常运行，因为 <code>systemctl</code> 已经在大多数 Linux 发行版中集成了，如果无法运行那么请使用 <code>sudo service docker start</code> 命令。这是另一种可以在 Linux 开机时自动启动 Docker。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p><code>DockerFile</code> 是一个如何构建镜像的说明文件。这个文件通常首先会指定一个基础的 Docker 镜像，例如，如何需要构建一个基于 python 开发的 API 程序 ，那么就可以使用一个安装了 python 环境的 Linux 操作系统作为 Docker 基础镜像，指定这个基础镜像之后使用其他指令来构建 Docker 镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用安装了Node12.16.1版本的Linux操作系统作为基础镜像</span><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">12.16</span>.<span class="hljs-number">1</span>-alpine3.<span class="hljs-number">11</span><br><br><span class="hljs-comment"># Installs some dependencies required for the Node.js API</span><br><span class="hljs-comment"># 安装 Node.js 依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache make g++</span><br><br><span class="hljs-comment"># Indicates that the API exposes port 3000</span><br><span class="hljs-comment"># 对外暴露 3000 端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><br><span class="hljs-comment"># Specifies the working directory. All the paths referenced after this point will be relative to this directory.</span><br><span class="hljs-comment"># 指定工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span><br><br><span class="hljs-comment"># Copy all local source files into the Docker container&#x27;s working directory</span><br><span class="hljs-comment"># 将本地文件复制到镜像的工作目录当中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># Installs NPM dependencies using yarn</span><br><span class="hljs-comment"># 使用 yarn 安装项目依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yarn install</span><br><br><span class="hljs-comment"># Command to start the API which will get executed when a Docker container using this image is started.</span><br><span class="hljs-comment"># 当容器运行的时候将会执行 yarn start 命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">&quot;yarn&quot;</span>, <span class="hljs-string">&quot;start&quot;</span> ]</span><br></code></pre></td></tr></table></figure><p>下面列出了常用的指令说明，完整的列表请查看 <a href="https://docs.docker.com/engine/reference/builder/">Docker 官方文档</a></p><table><thead><tr><th align="left">Instruction</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#from"><code>FROM</code></a></td><td align="left">Defines a base image 定义一个基础的镜像</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#run"><code>RUN</code></a></td><td align="left">Executes command in a new image layer 在镜像上执行命令</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#cmd"><code>CMD</code></a></td><td align="left">Command to be executed when running a container 容器运行时执行的命令</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#expose"><code>EXPOSE</code></a></td><td align="left">Documents which ports are exposed (not used for anything other than documentation) 容器对外暴露的端口</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#env"><code>ENV</code></a></td><td align="left">Sets environment variables 设置环境变量</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#copy"><code>COPY</code></a></td><td align="left">Copies files&#x2F;directories into the image 把文件复制到镜像中</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#add"><code>ADD</code></a></td><td align="left">A more feature-rich version of the <code>COPY</code> instruction. <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy"><code>COPY</code> is preferred</a> over <code>ADD</code>. 功能更强大的COPY指令，但是COPY指令优于ADD</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#entrypoint"><code>ENTRYPOINT</code></a></td><td align="left">Define a container’s executable. See the difference between the <code>CMD</code> instruction <a href="https://phoenixnap.com/kb/docker-cmd-vs-entrypoint">here</a>. 入口点</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#volume"><code>VOLUME</code></a></td><td align="left">Defines which directory in an image should be treated as a volume. The volume will be given a random name which can be found using <code>docker inspect</code> command.定义镜像中应该被视为卷的目录。该卷将被赋予一个随机名称，可以使用 <code>docker inspect</code> 命令找到它。</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#workdir"><code>WORKDIR</code></a></td><td align="left">Defines the working directory for subsequent instructions in the <code>Dockerfile</code> 指定工作目录</td></tr><tr><td align="left"><a href="https://docs.docker.com/engine/reference/builder/#arg"><code>ARG</code></a></td><td align="left">Defines variables that can be passed by the <code>docker build --build-arg</code> command and used within the <code>Dockerfile</code>.定义可以通过<code>docker build --build-arg</code>命令传递并在Dockerfile中使用的变量。</td></tr></tbody></table><p>如果有一些文件不需要复制到 Docker 镜像当中，那么可是在 Dockerfile 同级目录下面添加一个 <code>.dockerignore</code>文件，这样使用 <code>COPY</code>或 <code>ADD</code>指令的时候将不会把<code>.dockerignore</code>中指定文件复制到Docker镜像当中。更多关于<code>.dockerignore</code> 语法问题请参考这个<a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">链接</a>。</p><h2 id="Docker-images"><a href="#Docker-images" class="headerlink" title="Docker images"></a>Docker images</h2><p>Docker镜像由多个层组成（类似于洋葱），每层叠加之后，从外部看就如同一个独立的对象。镜像内部是一个精简的操作系统，同时还包含应用运行所必须的文件和依赖包。因为容器的设计初衷就是快速和小巧，所以镜像通常比较小。</p><h3 id="构建镜像和给镜像打标签"><a href="#构建镜像和给镜像打标签" class="headerlink" title="构建镜像和给镜像打标签"></a>构建镜像和给镜像打标签</h3><p>使用 <code>docker build </code>命令来创建镜像，当构建镜像时会提供一个 <code>--tag</code>选项给镜像打标签，这样就知道从镜像仓库中使用哪个镜像，或者在运行容器时使用哪个镜像了。 </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build --tag my-app:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> . <br><span class="hljs-comment"># --tag 可以简写成 -t</span><br><span class="hljs-attribute">docker</span> build -t my-app:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> .<br></code></pre></td></tr></table></figure><p><img src="https://static.aalmix.com/image-20210516164412510.png" alt="image-20210516164412510"></p><p>分解上面的命令</p><ul><li><code>docker build</code> 指定正在创建Docker镜像</li><li><code>--tag my-app:1.0</code> 指定给镜像命名为 my-app 并且标记为1.0 版本</li><li><code>.</code>  最后一个点表示 Docker 镜像是由当前目录的Dockerfile 构建的。</li></ul><p>使用 <code>docker images</code> 命令可以查看所有的本地的镜像，这样就可以验证镜像刚刚已经创建成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure><p><img src="https://static.aalmix.com/image-20210516164445416.png" alt="image-20210516164445416"></p><p>如果构建镜像时只有 <code>--tag</code>并没有指定版本的话，那么默认使用的版本就是 <code>latest</code>。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker build --<span class="hljs-keyword">tag</span> <span class="hljs-title">my-app</span> .<br>docker images<br></code></pre></td></tr></table></figure><p><img src="https://static.aalmix.com/image-20210516164919632.png" alt="image-20210516164919632"></p><p>除了使用 <code>docker build --tag </code> 命令给镜像打标签之外，还可以使用 <code>docker tag</code>命令。因为同一个镜像可以有多个标签，使用<code>docker tag </code>可以给通过<code>docker build --tag</code>构建的镜像打上新的标签。<br><img src="https://static.aalmix.com/image-20210516170500356.png" alt="image-20210516170500356"></p><p>注意：现在my-app有多个镜像版本，它们的 Image ID 都相同但 Repository Name 却不同，但实际上它们都同一个镜像，Repository Name 与使用 <code>docker push</code>将镜像推送到Docker镜像仓库的名称有关，在此处不详细展开讲。</p><blockquote><p>注意镜像的标签是可变的</p><p>假设镜像golftrack:1.5存在一个已知的Bug。因此可以拉取该镜像后修复它，并使用相同的标签将更新的镜像重新推送回仓库。一起来思考下刚才发生了什么。镜像golftrack:1.5存在Bug，这个镜像已经应用于生产环境。如果创建一个新版本的镜像，并修复了这个Bug。那么问题来了，构建新镜像并将其推送回仓库时使用了与问题镜像相同的标签！原镜像被覆盖，但在生产环境中遗留了大量运行中的容器，没有什么好办法区分正在使用的镜像版本是修复前还是修复后的，因为两个镜像的标签是相同的！</p><p>这个时候就不要通过镜像的摘要进行获取镜像了</p><p>docker image pull nginx@sha256:c3dcdb92d7432d56604d….</p></blockquote><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><p>使用<code>docker images</code> 或 <code>docker images ls</code> 命令可以列出当前本地可用的Docker 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br>docker images <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><h3 id="拉取和推送镜像"><a href="#拉取和推送镜像" class="headerlink" title="拉取和推送镜像"></a>拉取和推送镜像</h3><p>Docker 镜像可以保存在Docker镜像注册中心，默认的中心是 Docker Hub 。从Docker Hub拉取镜像使用<code>docker pull</code>命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull nginx:<span class="hljs-number">1</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>上面的命令将从Docker Hub 拉取官方的 1.18.0 版本的 nginx 镜像。<br><img src="https://static.aalmix.com/image-20210516172205211.png" alt="image-20210516172205211"></p><p>如果不指定nginx 的版本，默认会拉取标记为<code>latest</code>最新的版本。</p><p>上面使用nginx 镜像都是来自Docker Hub的官方镜像，官方的镜像一般都是经过Docker Hub正式批准的镜像，并且这些镜像会定期进行安全漏洞测试。</p><p>任何人都可以在Docker Hub上创建自己的账号和仓库，并箱仓库中推送镜像。把镜像推送到Docker Hub意味着镜像被保存在Docker Hub 中。docker push 命令的形式类似下面的命令</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">docker push <span class="hljs-tag">&lt;<span class="hljs-name">hub-user</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">repo-name</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span> <br></code></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>使用 <code>docker rmi</code> 或 <code>docker image rm</code> 命令可以删除镜像</p><p>如果镜像已经被容器使用，那么需要先删除容器然后再删除镜像，或者使用<code>docker rmi </code>命令加上<code>--focus</code> 选项</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rmi --focus my-app:<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里有两个命令，可以一次性清除所有镜像</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker rmi <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">images</span> -<span class="hljs-params">a</span> -<span class="hljs-params">q</span>)</span>  # remove all images<br>docker rmi <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">images</span> -<span class="hljs-params">a</span> -<span class="hljs-params">q</span>)</span> -f  # same <span class="hljs-keyword">as</span> above, but forces the images associated <span class="hljs-keyword">with</span> running containers <span class="hljs-keyword">to</span> also be removed<br></code></pre></td></tr></table></figure><h3 id="保存和加载镜像"><a href="#保存和加载镜像" class="headerlink" title="保存和加载镜像"></a>保存和加载镜像</h3><p>在某些情况下，需要将镜像保存到一个文件中，然后重新加载到Docker主机当中。使用<code>docker save</code>命令保存镜像</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">save</span> --output my-<span class="hljs-keyword">app</span>.tar my-<span class="hljs-keyword">app</span>:1.0 <br></code></pre></td></tr></table></figure><p>上面命令是将1.0版本的my-app 镜像保存成 tar 文件，然后我们可以使用<code>docker load</code>命令将新保存的 tar 文件加载到Docker 主机当中</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">docker <span class="hljs-built_in">load</span> <span class="hljs-comment">--input my-app.tar</span><br></code></pre></td></tr></table></figure><h2 id="Docker-container"><a href="#Docker-container" class="headerlink" title="Docker container"></a>Docker container</h2><p>我们可以把容器看做是镜像的运行时实例。</p><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>通过 <code>docker run </code> 命令启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run my-app:1.0<br></code></pre></td></tr></table></figure><p>上面的命令将会使用 my-app 1.0 的镜像创建容器，执行 <code>docker run </code>命令后将会启动容器，还会执行在 Dockerfile 中指定的 CMD 命令。使用 <code>docker ps </code>命令可以列出当前所有正在运行的容器。</p><p>容器创建成功后，Docker会随机生成一个 ContainerID 和 Container Name给容器，我们也可以通过添加 <code>--name </code>参数给容器取个好记的名字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name my-app my-app:1.0<br></code></pre></td></tr></table></figure><p>通过上面的命令将运行一个叫<code>my-app</code>名字的容器</p><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><p>默认情况下使用<code>docker run</code> 命令运行容器时会将容器中进程的执行日志实时的输出到当前启动的控制台，然而我们可以通过使用 <code>-d</code> 参数在让容器在后台下运行容器，这样就可以继续在控制台中执行命令</p><p>[配图说明区别]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d my-app:1.0 <br></code></pre></td></tr></table></figure><p>如果使用 <code>-d</code>参数在后台运行容器，那么我们可以使用<code>docker logs</code>命令查下容器的日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过容器ID查看</span><br>docker logs 容器ID<br><span class="hljs-comment"># 通过容器名称查看</span><br>docker logs my-app <br></code></pre></td></tr></table></figure><h3 id="暴露端口"><a href="#暴露端口" class="headerlink" title="暴露端口"></a>暴露端口</h3><p>如果容器自身提供一个端口（例如3000），但是在局域网中访问 <code>http://localhost:3000</code>是访问不到的，还需要使用下面命令将容器的3000端口映射给 Docker主机的 4000 端口，这个时候在局域网就能正常访问 <code>http://localhost:4000</code> 了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">4000</span>:<span class="hljs-number">3000</span> my-app:<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-comment"># 4000 属于主机端口，3000 属于容器自身端口</span><br></code></pre></td></tr></table></figure><h3 id="停止和删除容器"><a href="#停止和删除容器" class="headerlink" title="停止和删除容器"></a>停止和删除容器</h3><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><h3 id="在容器中执行命令"><a href="#在容器中执行命令" class="headerlink" title="在容器中执行命令"></a>在容器中执行命令</h3><p>要在正在运行的容器中运行命令，请使用 <code>docker exec</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> my-app <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>如果想进入容器里面执行命令，需要使用一下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it my-app bash<br></code></pre></td></tr></table></figure><h3 id="查看容器详情"><a href="#查看容器详情" class="headerlink" title="查看容器详情"></a>查看容器详情</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker inspect my-app<br></code></pre></td></tr></table></figure><h2 id="Docker-Volumes"><a href="#Docker-Volumes" class="headerlink" title="Docker Volumes"></a>Docker Volumes</h2><h2 id="Docker-networks"><a href="#Docker-networks" class="headerlink" title="Docker networks"></a>Docker networks</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="使用-Dockerfile-和-save-打包镜像的区别"><a href="#使用-Dockerfile-和-save-打包镜像的区别" class="headerlink" title="使用 Dockerfile 和 save 打包镜像的区别"></a>使用 Dockerfile 和 save 打包镜像的区别</h3><ul><li><p>Dockerfile 可以查看详细的历史</p></li><li><p>使用 docker save 的方式就无法查看打包的历史了，外人不知道作者给镜像做了什么具体的操作</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://robertcooper.me/post/docker-guide#removing-images">Docker guide (robertcooper.me)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-指南&quot;&gt;&lt;a href=&quot;#Docker-指南&quot; class=&quot;headerlink&quot; title=&quot;Docker 指南&quot;&gt;&lt;/a&gt;Docker 指南&lt;/h1&gt;&lt;p&gt;本文的目的是解释与 Docker 相关的重要概念，以便能够有效的使用 Docker </summary>
      
    
    
    
    
    <category term="docker" scheme="https://blog.aalmix.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>让 nginx 支持多域名站点</title>
    <link href="https://blog.aalmix.com/2021/05/19/nginx-support-many-domain/"/>
    <id>https://blog.aalmix.com/2021/05/19/nginx-support-many-domain/</id>
    <published>2021-05-19T18:45:30.000Z</published>
    <updated>2023-03-18T05:41:24.225Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>现在有2个域名，网站部署都同一个公网IP服务器上面，其中站点A已经占用了公网IP的 80 端口，现在想实现两个域名都能通过80端口访问，域名B 访问时不需要添加端口号</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">www.siteA.com</span> =&gt; <span class="hljs-number">111.111</span>.<span class="hljs-number">111.111</span>:<span class="hljs-number">80</span><br><span class="hljs-attr">www.siteB.com</span> =&gt; <span class="hljs-number">111.111</span>.<span class="hljs-number">111.111</span>:<span class="hljs-number">9091</span><br></code></pre></td></tr></table></figure><h4 id="之前的做法"><a href="#之前的做法" class="headerlink" title="之前的做法"></a>之前的做法</h4><p>域名A的解析保持不变，域名B 在DNS解析中添加一个隐性URL记录。</p><p><img src="https://static.aalmix.com/20210519194401.png" alt="image-20210519193856059"></p><p>当我们访问域名B的时候，浏览器返回的一串下图所示的HTML代码，本质上还是嵌套一个 frame 。</p><p><img src="https://static.aalmix.com/20210519194405.png" alt="image-20210519192104079"></p><p>但是这样无法正常显示域名B的标题，本来想通过 JS 代码去修改，奈何由于浏览器跨域的安全性问题导致无法修改，只要作罢。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>后来还是通过 nginx 解决，在 nginx.conf 中配置两个 server，同时监听 80 端口，当使用浏览器访问不同的域名时，通过 nginx 代理转发到实际程序的端口上。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><br><span class="hljs-comment">#user  nobody;</span><br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">#error_log  logs/error.log;</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;</span><br><span class="hljs-comment">#error_log  logs/error.log  info;</span><br><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">100M</span>;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><br>    <span class="hljs-comment">#access_log  logs/access.log  main;</span><br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  www.siteA.com;  <span class="hljs-comment"># 站点A</span><br>        <span class="hljs-attribute">charset</span> UTF-<span class="hljs-number">8</span>;<br>        <span class="hljs-section">location</span> / &#123;            <br>            <span class="hljs-attribute">proxy_pass</span> http://localhost:9090;<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  www.siteB.com; <span class="hljs-comment"># 站点B</span><br>        <span class="hljs-attribute">charset</span> UTF-<span class="hljs-number">8</span>;<br>        <span class="hljs-section">location</span> / &#123;            <br>            <span class="hljs-attribute">proxy_pass</span> http://localhost:9091;<br>        &#125;<br><span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span>  /<span class="hljs-number">404</span>.html; <br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h4&gt;&lt;p&gt;现在有2个域名，网站部署都同一个公网IP服务器上面，其中站点A已经占用了公网IP的 80 端口，现在想实现两个域名都能通过80端口访问，域名</summary>
      
    
    
    
    
    <category term="nginx" scheme="https://blog.aalmix.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx_413_request_entity_too_large</title>
    <link href="https://blog.aalmix.com/2021/05/19/nginx-413-request-entity-too-large/"/>
    <id>https://blog.aalmix.com/2021/05/19/nginx-413-request-entity-too-large/</id>
    <published>2021-05-19T13:40:07.000Z</published>
    <updated>2023-03-18T05:41:24.221Z</updated>
    
    <content type="html"><![CDATA[<p>最近客户反映新闻内容上传图片有的时候会出现失败的情况，一开始判断是图片太大导致超时出现的问题，仔细查看发现上传文件的请求出现了 <code>413 request entity too large</code> 的错误，而且这个错误是 nginx 返回的。</p><p><img src="https://static.aalmix.com/20210519145507.png" alt="image-20210519134645333"></p><p><img src="https://static.aalmix.com/20210519145510.png" alt="微信截图_20210519112536"></p><p>查找资料发现 nginx 默认请求的大小只有 1M，后来在 nginx.conf 配置文件中改成 100M 就解决了这个问题。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># nginx.conf </span><br>http &#123;<br>    client_max_body_size 100M;<br>    <span class="hljs-string">...</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size">http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近客户反映新闻内容上传图片有的时候会出现失败的情况，一开始判断是图片太大导致超时出现的问题，仔细查看发现上传文件的请求出现了 &lt;code&gt;413 request entity too large&lt;/code&gt; 的错误，而且这个错误是 nginx 返回的。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    
    <category term="nginx" scheme="https://blog.aalmix.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>在windows服务器上将nginx安装成服务</title>
    <link href="https://blog.aalmix.com/2021/05/19/nginx-run-as-windows-service/"/>
    <id>https://blog.aalmix.com/2021/05/19/nginx-run-as-windows-service/</id>
    <published>2021-05-19T12:46:06.000Z</published>
    <updated>2023-03-18T05:41:24.225Z</updated>
    
    <content type="html"><![CDATA[<p>在 windows 服务器上将 nginx 注册成服务需要借助第三方软件 <code>Windows Service Wrapper</code>，简称 winsw，下面介绍如何使用</p><ol><li><p>首先去下载 winsw 软件，<a href="https://github.com/winsw/winsw/releases">下载地址</a>, 我下载的是 <code>WinSW.NET4.exe</code> ,因为我的服务器上安装了 .NET Framework 4.0，当然你也可以选择下载其他的版本，然后把下载后的文件放在和 nginx.exe 相同目录当中。</p><p><img src="https://static.aalmix.com/20210519133028.png" alt="image-20210519130237719"></p></li><li><p>将 <code>WinSW.NET4.exe</code> 文件重命名为 <code>nginx-service.exe</code>，这样方便在任务管理器中查找进程。</p><p><img src="https://static.aalmix.com/20210519133034.png" alt="image-20210519132458822"></p></li><li><p>创建 <code>nginx-service.xml</code> 文件，将下面的内容复制进去（你可能需要改下nginx的路径）</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nginx<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nginx Service<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>High Performance Nginx Service<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>D:\soft\nginx-1.20.0\nginx.exe<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">logpath</span>&gt;</span>D:\soft\nginx-1.20.0\<span class="hljs-tag">&lt;/<span class="hljs-name">logpath</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">logmode</span>&gt;</span>roll<span class="hljs-tag">&lt;/<span class="hljs-name">logmode</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">stopargument</span>&gt;</span>-s<span class="hljs-tag">&lt;/<span class="hljs-name">stopargument</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">stopargument</span>&gt;</span>stop<span class="hljs-tag">&lt;/<span class="hljs-name">stopargument</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：<strong>停止的参数需要分开写成2行，要不然停止 nginx 服务会不成功</strong></p></blockquote><ol start="4"><li>在命令行中运行 <code>nginx-service.exe install</code> 安装服务，安装成功后，你可以在服务中查看到</li></ol><p><img src="https://static.aalmix.com/20210519133037.png" alt="微信截图_20210519130929"></p><p>后面你可以通过下面的命令管理 nginx 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">net start nginx  <span class="hljs-comment"># 启动服务</span><br>net stop nginx   <span class="hljs-comment"># 停止服务</span><br><br>nginx-service.exe start <span class="hljs-comment"># 查看服务状态</span><br>nginx-service.exe status <span class="hljs-comment"># 查看服务状态</span><br>nginx-service.exe stop  <span class="hljs-comment"># 停止服务</span><br>nginx-service.exe restart  <span class="hljs-comment"># 重启服务</span><br>nginx-service.exe uninstall  <span class="hljs-comment"># 卸载服务</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 windows 服务器上将 nginx 注册成服务需要借助第三方软件 &lt;code&gt;Windows Service Wrapper&lt;/code&gt;，简称 winsw，下面介绍如何使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先去下载 winsw 软件，&lt;a href=&quot;https</summary>
      
    
    
    
    
    <category term="nginx" scheme="https://blog.aalmix.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数作用域的解释</title>
    <link href="https://blog.aalmix.com/2020/12/20/JavaScript%20%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%A3%E9%87%8A/"/>
    <id>https://blog.aalmix.com/2020/12/20/JavaScript%20%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%A3%E9%87%8A/</id>
    <published>2020-12-20T15:51:29.000Z</published>
    <updated>2023-03-18T05:41:24.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-函数作用域的解释"><a href="#JavaScript-函数作用域的解释" class="headerlink" title="JavaScript 函数作用域的解释"></a>JavaScript 函数作用域的解释</h1><p>本文将解释作用域的相关概念，我们将学习并理解作用域链的重要性。</p><h2 id="测验时间"><a href="#测验时间" class="headerlink" title="测验时间"></a>测验时间</h2><p>下面的代码执行后将会打印出什么？为什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jerry</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tom</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;tom&#x27;</span>;<br>  <span class="hljs-title function_">jerry</span>();<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;cartoon&#x27;</span>;<br><br><span class="hljs-title function_">tom</span>();<br><br></code></pre></td></tr></table></figure><p>是打印出 <code>cartoon</code>, <code>tom</code> 还是 <code>undefined</code> 吗? 更重要的是，你是怎么判断然后得到答案的？你用到了作用域了，执行上下文了吗？</p><h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域 Scope"></a>作用域 Scope</h2><p>上面题目的答案是，<code>cartoon</code>。 让我们进一步探索和理解它吧</p><blockquote><p><em>In JavaScript, Scope is the mechanism to determine the accessibility of variables throughout their existence. It could be inside or outside of a function call.</em></p></blockquote><p>首先让我们将上面的代码拆分成几部分，然后看看变量的可访问性是如何随着变量声明的位置和函数的位置的变化而变化的。</p><h2 id="回顾一下"><a href="#回顾一下" class="headerlink" title="回顾一下"></a>回顾一下</h2><p>以下是我们对 JavaScript 执行上下文理解的一些要点：</p><ul><li>有一个叫做全局执行上下文（<code>Global Execution Context</code>）和函数执行上下文(<code>Function Execution Context</code>)的东西</li><li>每一个执行上下文都有一个特殊的　<code>this</code>  和 外部环境引用 <code>reference to the Outer Environment</code></li><li>当我们调用函数时，JavaScript 引擎会创建当前函数的执行上下文和一个外部引用</li><li>函数可以访问外部引用中定义的变量。当 JavaScript 引擎无法在当前执行上下文中找到变量的时候，它就会去外部引用中去查找。</li></ul><h2 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h2><p>在上面的代码中，有2个函数调用，tom() 和 jerry() ，因此会创建2个不同的函数执行上下文。</p><p>请记住，JS代码执行的时候始终会创建一个全局执行上下文，其中关键字 <code>this</code> 等于 <code>window</code> 对象。 因此在上面的代码中我们总共有3个执行上下文，一个全局执行上下文，两个函数执行上下文，分别是 <code>tom()</code>和<code>jerry()</code> 。<br><img src="https://static.aalmix.com/20210309172743.jpg" alt="functions.png"></p><ul><li><p>代码执行的时候先会在全局执行上下文中创建一个 <code>name</code> 变量，然后给这个变量复制为 <code>cargoon</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;cartoon&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>当调用<code>tom()</code>函数，Javascript 引擎会给<code>tom()</code>创建一个函数执行上下文和一个外部环境的引用（全局执行上下文）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">tom</span>();<br></code></pre></td></tr></table></figure></li><li><p>当 tom() 函数调用 <code>jerry()</code> 函数时，JavaScript 引擎会找到 jerry 函数申明的位置，然后创建 <code>jerry()</code>函数的执行上下文和外部环境引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tom</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;tom&#x27;</span>;<br> <span class="hljs-title function_">jerry</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>等等，<code>jerry()</code> 函数的外部环境引用是谁？是 <code>tom()</code>函数的执行上下文还是全局执行上下文？这取决于另一个问题的答案</p><blockquote><p>谁调用了 jerry() 函数，它在哪里声明创建的？</p></blockquote><p><code>jerry()</code> 函数是在全局执行上下文中创建的，尽管它是在 tom() 函数中调用。按照要点2的理解，jerry() 函数有一个指向全局执行执行上下文的指针。</p><p>到目前为止，Are you OK ?  我们还发现，jerry() 函数中并没有申明 <code>name</code> 变量，但是在执行阶段它却尝试在控制台打印这个 <code>name</code> 变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jerry</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，JavaScript 引擎会去 jerry() 函数的外部引用（全局执行上下文）中去查找 <code>name</code> 变量，然后它在全局执行上下文中找到了 cartoon 这个值。</p><p>现在我们知道答案为什么是 <code>cartoon</code> 了吧。</p><p><img src="https://static.aalmix.com/20210309172749.gif" alt="flow1"></p></li></ul><p>​    </p><p>在当前执行上下文和外部引用中查找变量的整个过程就形成了的链条叫做<code>作用域链</code>。我们还可以得出结论，变量<code>name</code>在函数 jerry() 的作用域中，因为它是在 jerry() 函数作用域中被找到的。</p><p><img src="https://static.aalmix.com/20210309172753.jpg" alt="scope_chain"></p><h2 id="作用域的变化"><a href="#作用域的变化" class="headerlink" title="作用域的变化"></a>作用域的变化</h2><p>测试时间又到了！下面的代码将会打印出什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tom</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;tom&#x27;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">jerry</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>  &#125;<br>  <span class="hljs-title function_">jerry</span>();<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;cartoon&#x27;</span>;<br><br><span class="hljs-title function_">tom</span>();<br></code></pre></td></tr></table></figure><p>这次我们稍微做了一些小改动，现在 jerry() 函数是在 tom() 函数里面创建的。jerry() 函数的外部引用将会指向 tom() 函数的执行上下文。因此变量 <code>name</code> 将在tom() 函数的作用域链中被找到。所以，上面的答案就是 <code>tom</code> !</p><p><img src="https://static.aalmix.com/20210309172759.gif" alt="flow2"></p><h2 id="块级作用域-Block-Scope"><a href="#块级作用域-Block-Scope" class="headerlink" title="块级作用域 Block Scope"></a>块级作用域 Block Scope</h2><p>既然我们理解了作用域的基本原理，那么就让我们来理解一下什么是块级作用域。代码块通过大括号定义<code>&#123;...&#125;</code>。</p><p>如果在代码块中使用 <code>let</code> 关键字申明变量，那么变量只在这个代码块中可以被访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;tom&quot;</span>; <span class="hljs-comment">// only visible in this block</span><br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// tom</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// Error: name is not defined</span><br></code></pre></td></tr></table></figure><p>如果我们使用 <code>var</code> 而不是 <code>let</code>  创建变量，就不存这个块级作用域了。</p><p>另一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-comment">// declare name</span><br>  <span class="hljs-keyword">let</span> name= <span class="hljs-string">&quot;tom&quot;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;<br><br>&#123;<br>  <span class="hljs-comment">// declare name in another block</span><br>  <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;jerry&quot;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码会在控制台中分别打印 tom 和 jerry 。</p><p>即使对于 <code>if</code>, for , while 等等，使用了 <code>let</code> 在块级作用域中声明的代码也只能在块中访问，下面是 for 循环的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-number">10</span>; counter++) &#123;<br>  <span class="hljs-comment">// the variable counter is with let </span><br>  <span class="hljs-comment">// hence visible only inside the block &#123;...&#125;</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter); <br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter); <span class="hljs-comment">// Error, counter is not defined</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解作用域的基本概念，比如执行上下文、外部引用等等，将有助于我们调试代码，作为 JavaScript 的开发者，我们对于了解JavaScript 内部代码的工作方式更有信息。</p><p>引用</p><ul><li><a href="https://leanpub.com/ydkjsy-scope-closures/read_sample">Scope and Closure</a> from You don’t know JS yet series.</li><li><a href="https://javascript.info/closure">Variable Scope</a> from <a href="http://javascript.info/">javascript.info</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Scope">https://developer.mozilla.org/en-US/docs/Glossary/Scope</a></li></ul><p>文章来源： <a href="https://blog.greenroots.info/javascript-scope-fundamentals-with-tom-and-jerry-ckcq723h4007vkxs18dxa97ae">https://blog.greenroots.info/javascript-scope-fundamentals-with-tom-and-jerry-ckcq723h4007vkxs18dxa97ae</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-函数作用域的解释&quot;&gt;&lt;a href=&quot;#JavaScript-函数作用域的解释&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 函数作用域的解释&quot;&gt;&lt;/a&gt;JavaScript 函数作用域的解释&lt;/h1&gt;&lt;p&gt;本文</summary>
      
    
    
    
    
    <category term="javascript" scheme="https://blog.aalmix.com/tags/javascript/"/>
    
    <category term="函数作用域" scheme="https://blog.aalmix.com/tags/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>frp使用systemd在linux系统下实现开机自动运行</title>
    <link href="https://blog.aalmix.com/2020/12/20/frp%E4%BD%BF%E7%94%A8systemd%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/"/>
    <id>https://blog.aalmix.com/2020/12/20/frp%E4%BD%BF%E7%94%A8systemd%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/</id>
    <published>2020-12-20T15:51:29.000Z</published>
    <updated>2023-03-18T05:41:24.221Z</updated>
    
    <content type="html"><![CDATA[<p>Systemd 是 Linux 系统系统工具，用来启动守护进程，已经成为了大多数发行版本的标准配置。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 查看 Systemd 版本</span><br>systemctl <span class="hljs-comment">--version  </span><br></code></pre></td></tr></table></figure><p>frp 也是支持 Systemd 的，我们下载的frp文件当中就包含了一个 systemd 文件夹，里面就包含了 frps 和 frpc 的服务配置文件</p><p><img src="https://static.aalmix.com/20201220165016.png" alt="image-20201220160339843"></p><p>我们使用 cat 命令查看一下配置文件内容 <code>cat frps.service</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Frp Server Service<br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple<br><span class="hljs-attr">User</span>=nobody<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span>s<br><span class="hljs-attr">ExecStart</span>=/usr/bin/frps -c /etc/frp/frps.ini<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><br></code></pre></td></tr></table></figure><p>我们可以看到 frps 的执行路径是 <code>/usr/bin/frps</code>，配置文件放在 <code>/ect/frp/frps.ini</code>，</p><p>Systemd 的配置文件都放在 <code>/lib/systemd/system</code> 目录下，系统开机启动的时候之后只执行这个目录里的配置文件，所以我们只要把 <code>frps.service</code>复制到 <code>/lib/systemd/system</code> ，frps 复制到 <code>/usr/bin</code>目录，fprs.ini 复制到<code>/etc/frp</code>目录就可以了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp frps <span class="hljs-regexp">/usr/</span>bin/frps<br>sudo mkdir <span class="hljs-regexp">/etc/</span>frp<br>sudo cp frps.ini <span class="hljs-regexp">/etc/</span>frp/frps.ini<br>sudo cp systemd<span class="hljs-regexp">/frps.service /</span>lib<span class="hljs-regexp">/systemd/</span>system/frps.service<br><br></code></pre></td></tr></table></figure><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment"># 重新加载 system 配置文件</span><br>sudo <span class="hljs-params">system</span>ctl daemon-reload<br><span class="hljs-comment"># 设置 frps 开机启动</span><br>sudo <span class="hljs-params">system</span>ctl enable frps.service<br><br></code></pre></td></tr></table></figure><p><img src="https://static.aalmix.com/20201220165207.png" alt="image-20201220164646349"></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment"># 启动 frps 服务</span><br>sudo <span class="hljs-params">system</span>ctl start frps.service<br><span class="hljs-comment"># 查看服务器状态</span><br>sudo <span class="hljs-params">system</span>ctl status frps.service<br></code></pre></td></tr></table></figure><p><img src="https://static.aalmix.com/20201220165202.png" alt="image-20201220164606524"></p><p>参考链接 </p><ul><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">Systemd 入门教程：命令篇</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd 入门教程：实战篇</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Systemd 是 Linux 系统系统工具，用来启动守护进程，已经成为了大多数发行版本的标准配置。&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    
    <category term="frp" scheme="https://blog.aalmix.com/tags/frp/"/>
    
    <category term="systemd" scheme="https://blog.aalmix.com/tags/systemd/"/>
    
    <category term="linux" scheme="https://blog.aalmix.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>frp搭配nginx将https请求映射到内网</title>
    <link href="https://blog.aalmix.com/2020/12/19/frp%E6%90%AD%E9%85%8Dnginx%E5%B0%86https%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E7%BD%91/"/>
    <id>https://blog.aalmix.com/2020/12/19/frp%E6%90%AD%E9%85%8Dnginx%E5%B0%86https%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E7%BD%91/</id>
    <published>2020-12-19T16:01:12.000Z</published>
    <updated>2023-03-18T05:41:24.221Z</updated>
    
    <content type="html"><![CDATA[<p>最近做微信小程序开发，发现正式发布的时候后台 webapi 服务必须是 https 协议的，当然开发的时候可以勾选不校验域名<br><img src="https://static.aalmix.com/20201219163456.png" alt="image-20201219160934257"></p><p>我们之前使用 frp 将内网服务映射出去后只能提供 http 协议的形式访问，无法使用 https 协议，这个怎么办呢？</p><p>经过一番资料查找，发现需要搭配 nginx 一起使用就可以解决。<br><img src="https://static.aalmix.com/image-20230218223202953.png" alt="image-20230218223202953"></p><p>首先我们需要给我们的域名申请一个免费的 SSL 证书，腾讯云和阿里云都有免费的。</p><p>第二步，配置内网 fprc.ini ，这里我们将本地的 8099 端口映射到远程的 8099 端口</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = 云服务器IP地址<br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">token</span> = <span class="hljs-number">123456</span><br><span class="hljs-section">[wx_webapi]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">8099</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">8099</span><br></code></pre></td></tr></table></figure><p>服务器端的配置 frps.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">token</span> = <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>这样我们就可以通过访问 http:&#x2F;&#x2F;云服务器 IP 地址:8099 访问内网的 webapi 了</p><p>第三步，在云服务器上使用下面的命令安装 nginx</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install nginx<br></code></pre></td></tr></table></figure><p>第四步，将申请的 SSL 证书复制到云服务器上，并开始配置 nginx ，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">server&#123;<br>    ssl on;<br>    listen <span class="hljs-number">18099</span>;<br>    server_name www.abc.com;      <span class="hljs-comment"># 域名</span><br>    ssl_certificate server.crt;      <span class="hljs-comment"># 配置 SSL 证书</span><br>    ssl_certificate_key server.key;  <span class="hljs-comment"># 配置 SSL 证书</span><br>    ssl_session_timeout <span class="hljs-number">5</span>m;<br><br>    location / &#123;<br>        proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8099</span>; <span class="hljs-comment">#外部请求18099端口时，nginx会将请求代理转发到本地的8099端口</span><br>        proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>        proxy_set_header Connection <span class="hljs-string">&quot;Upgrade&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第四步，启动 nginx</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-literal">start</span> nginx<br></code></pre></td></tr></table></figure><p>这样外部请求 18099 端口时，nginx 会将请求代理转发到本地的 8099 端口，也就是 frp 内网穿透的端口，</p><p>那么当我们请求 <a href="https://www.abc.com:18099/">https://www.abc.com:18099</a> 时，实际上请求的内网服务器的 8099 端口</p><p>这样我们就解决了 https 访问的问题了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近做微信小程序开发，发现正式发布的时候后台 webapi 服务必须是 https 协议的，当然开发的时候可以勾选不校验域名&lt;br&gt;&lt;img src=&quot;https://static.aalmix.com/20201219163456.png&quot; alt=&quot;image-2020</summary>
      
    
    
    
    
    <category term="frp" scheme="https://blog.aalmix.com/tags/frp/"/>
    
    <category term="nginx" scheme="https://blog.aalmix.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>如何在Markdown文档显示diff效果</title>
    <link href="https://blog.aalmix.com/2020/11/13/%E5%A6%82%E4%BD%95%E5%9C%A8Markdown%E6%96%87%E6%A1%A3%E6%98%BE%E7%A4%BAdiff%E6%95%88%E6%9E%9C/"/>
    <id>https://blog.aalmix.com/2020/11/13/%E5%A6%82%E4%BD%95%E5%9C%A8Markdown%E6%96%87%E6%A1%A3%E6%98%BE%E7%A4%BAdiff%E6%95%88%E6%9E%9C/</id>
    <published>2020-11-13T17:14:11.000Z</published>
    <updated>2023-03-18T05:41:24.229Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.wangbase.com/blogimg/asset/202011/bg2020110301.jpg" alt="img"></p><p>我最喜欢的一个博客技巧就是在 Github 风格的 markdown 中使用 diff 格式，使用这个这个技巧可以显示代码片段中修改的地方。</p><p>如果我想给其他人显示一个函数修改的状态历史，类似于下面的代码片段</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">function addTwoNumbers (num1, num2) &#123;<br><span class="hljs-deletion">- return 1 + 2</span><br><span class="hljs-addition">+ return num1 + num2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如何实现呢?</p><p>首先不要指定变成语言， 而是使用 <code>diff</code>，然后在需要显示成删除样式的代码的开头添加<code>-</code>，添加的代码的前面添加一个<code>+</code>，代码如下所示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">```diff<br>function addTwoNumbers (num1, num2) &#123;<br>-  return 1 + 2<br>+  return num1 + num2<br>&#125;<br>```<br></code></pre></td></tr></table></figure><p>OK！！</p><p>原文地址： <a href="https://welearncode.com/create-diff-markdown/">https://welearncode.com/create-diff-markdown/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/202011/bg2020110301.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;我最喜欢的一个博客技巧就是在 Github 风格的 markdown 中使用 diff 格</summary>
      
    
    
    
    
    <category term="Markdown" scheme="https://blog.aalmix.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>在windows上设置frp开机自动启动</title>
    <link href="https://blog.aalmix.com/2020/11/05/%E5%9C%A8windows%E4%B8%8A%E8%AE%BE%E7%BD%AEfrp%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8/"/>
    <id>https://blog.aalmix.com/2020/11/05/%E5%9C%A8windows%E4%B8%8A%E8%AE%BE%E7%BD%AEfrp%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8/</id>
    <published>2020-11-05T20:55:59.000Z</published>
    <updated>2023-03-18T05:41:24.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在之前的文章中介绍了在 Windows 上运行frp的客户端需要在命令行中输入一下命令</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">frpc.exe -<span class="hljs-keyword">c</span> frpc.ini<br></code></pre></td></tr></table></figure><p>但是如何不小心关掉了命令行窗口就需要手动重新打开，当然也可以把上面的命令复制后另存为run.bat文件，下次双击运行就可以使用，但是我们还是想实现开机自动运行，那么该如何做呢？</p><p>这个时候我们需要借助第三方的工具 <a href="https://nssm.cc/">nssm</a>， nssm 官网的介绍如下</p><blockquote><p><em>nssm</em> is a service helper which doesn’t suck. <em>srvany</em> and other service helper programs suck because they don’t handle failure of the application running as a service. If you use such a program you may see a service listed as started when in fact the application has died. <em>nssm</em> monitors the running service and will restart it if it dies. With <em>nssm</em> you know that if a service says it’s running, it really is. Alternatively, if your application is well-behaved you can configure <em>nssm</em> to absolve all responsibility for restarting it and let Windows take care of recovery actions.</p></blockquote><p>大概的意思就是 nssm 可以将程序注册成 windows 服务，并且会监听正在运行的服务，当服务死了之后会自动重启。</p><h3 id="下载-nssm"><a href="#下载-nssm" class="headerlink" title="下载 nssm"></a>下载 nssm</h3><p>先去 <a href="https://nssm.cc/download">https://nssm.cc/download</a> 这个地址下载 nssm, 下载后的文件非常小只有 300+ KB，算的上是短小精悍。</p><p><img src="https://static.aalmix.com/20201106173532.png" alt="image-20201105213254604"></p><h3 id="如何使用-nssm"><a href="#如何使用-nssm" class="headerlink" title="如何使用 nssm"></a>如何使用 nssm</h3><ol><li>进入命令行窗口，输入<code>nssm install </code></li></ol><p><img src="https://static.aalmix.com/20201106173550.png" alt="image-20201105213622063"></p><p><img src="https://static.aalmix.com/20201106173557.png" alt="image-20201105213739577"></p><ol start="2"><li>执行之后会显示下面这个页面，选择 frpc 程序的路径，以及启动的参数</li></ol><p><img src="https://static.aalmix.com/20201106173601.png" alt="image-20201105213843898"></p><p><img src="https://static.aalmix.com/20201106173603.png" alt="image-20201105214258612"></p><ol start="3"><li>填写服务的显示名称以及服务说明，还有启动方式，默认是自动自动</li></ol><p><img src="https://static.aalmix.com/20201106173606.png" alt="image-20201105214507281"></p><ol start="4"><li><p>配置程序输入和输出日志存放位置（可选）</p><p><img src="https://static.aalmix.com/20201106173609.png" alt="image-20201105215008339"></p><ol start="5"><li>点击 <code>Install service</code> 按钮安装服务</li></ol></li></ol><h3 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h3><p>按下<code>Win+R</code>键，在运行中输入<code>service.msc</code> 命令打开服务管理器，我们就可以看到刚刚安装的frp服务了，然后我们就向其他windows服务一样控制它启动，停止，重启了。</p><p><img src="https://static.aalmix.com/20201106173612.png" alt="image-20201105215255665"></p><p><img src="https://static.aalmix.com/20201106173615.png" alt="image-20201105215411888"></p><p>当前我们可以通过 nssm 的命令行的形式控制它</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># 启动</span><br>nssm start <span class="hljs-variable">&lt;servicename&gt;</span><br><br><span class="hljs-comment"># 停止</span><br>nssm stop <span class="hljs-variable">&lt;servicename&gt;</span><br><br><span class="hljs-comment"># 重启</span><br>nssm restart <span class="hljs-variable">&lt;servicename&gt;</span><br><br><span class="hljs-comment"># 修改服务配置</span><br>nssm edit <span class="hljs-variable">&lt;servicename&gt;</span><br><br><span class="hljs-comment"># 删除服务 </span><br>nssm remove <span class="hljs-variable">&lt;servicename&gt;</span><br><br></code></pre></td></tr></table></figure><p>参考： <a href="http://www.cnblogs.com/TianFang/p/7912648.html">www.cnblogs.com/TianFang/p/7912648.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;在之前的文章中介绍了在 Windows 上运行frp的客户端需要在命令行中输入一下命令&lt;/p&gt;
&lt;figure class=</summary>
      
    
    
    
    
    <category term="frp" scheme="https://blog.aalmix.com/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>使用frp内网穿透教程</title>
    <link href="https://blog.aalmix.com/2020/11/02/%E4%BD%BF%E7%94%A8frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.aalmix.com/2020/11/02/%E4%BD%BF%E7%94%A8frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/</id>
    <published>2020-11-02T17:27:46.000Z</published>
    <updated>2023-03-18T05:41:24.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>一台具有公网 IP 的服务器，可以去购买阿里云服务器，腾讯云服务器或者 Vultr</p></li><li><p>frp 工具软件可以去这个 <a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a> 地址下载 frp 的客户端和服务端软件，由于我自己服务器安装的是 ubuntu 64 位，客户端用的是 windows ，所以就下载了图片中红色标注的版本，大家可以根据自己的系统的版本去下载。linux_amd64.tar.gz 放在服务器上，windows_386 作为客户端使用</p><p><img src="https://static.aalmix.com/20201102173858.png" alt="image-20201102173221758"></p></li></ul><p>将文件下载解压后的文件目录大概是这个样子，frpc, frpc.ini 主要是客户端使用，frps, frps.ini 主要是服务器端使用。</p><p><img src="https://static.aalmix.com/20201102173902.png" alt="image-20201102173208329"></p><h2 id="frp-配置"><a href="#frp-配置" class="headerlink" title="frp 配置"></a>frp 配置</h2><h3 id="服务端-frps-ini-文件配置"><a href="#服务端-frps-ini-文件配置" class="headerlink" title="服务端 frps.ini 文件配置"></a>服务端 frps.ini 文件配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-comment"># 服务端与客户端通信使用的端口</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-comment"># 客户端和服务端通信的认证信息</span><br><span class="hljs-attr">token</span> = <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><h3 id="客户端-frpc-ini-文件配置"><a href="#客户端-frpc-ini-文件配置" class="headerlink" title="客户端 frpc.ini 文件配置"></a>客户端 frpc.ini 文件配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-comment"># 服务器IP</span><br><span class="hljs-attr">server_addr</span> = x.x.x.x<br><span class="hljs-comment"># 服务器端口，与 frps.ini 中的 bind_port 一致</span><br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-comment"># 客户端和服务端通信的认证信息</span><br><span class="hljs-attr">token</span> = <span class="hljs-number">123456</span><br><span class="hljs-comment"># 启用tls，frpc会使用 tls 加密连接服务器</span><br><span class="hljs-attr">tls_enable</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># [] 方括号里面的名称需要保证唯一</span><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-comment"># 客户端的 IP 地址</span><br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-comment"># 客户端需要映射出去的端口</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span><br><span class="hljs-comment"># 远程</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="1-使用-frp-实现内网机器的远程连接"><a href="#1-使用-frp-实现内网机器的远程连接" class="headerlink" title="1. 使用 frp 实现内网机器的远程连接"></a>1. 使用 frp 实现内网机器的远程连接</h3><p>将 frpc.ini 改成如下配置，假设 frps 所在服务器的公网 IP 为 x.x.x.x，我们需要将本地的 3389 端口（远程连接使用的端口）映射到远程的 7402 端口</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = x.x.x.x<br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">token</span> = <span class="hljs-number">123456</span><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">6000</span><br><span class="hljs-section">[mstsc]</span> <span class="hljs-comment"># 名字随便取，但不能重复</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">3389</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">7402</span><br></code></pre></td></tr></table></figure><p>在服务器端启动 frps</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/frps -c ./</span>frps.ini<br></code></pre></td></tr></table></figure><p>在客户端启动 frpc, windows 客户端需要使用命令行运行一下命令，不能直接双击运行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/frpc -c ./</span>frpc.ini<br></code></pre></td></tr></table></figure><p>然后我们就可以使用远程桌面连接我们内网的电脑了，注意端口使用的 remote_port，远程桌面的体验就取决于服务器的带宽了</p><p><img src="https://static.aalmix.com/20201102173908.png" alt="image-20201102173541252"></p><p>我们可以将多台电脑的 3389 端口映射出去，但需要每台电脑使用的 remote_port 不能相同，[mstsc] 也不能相同，如果同时已经开了 1 台电脑的远程连接，那么远程第二台的时候需要选择其它用户进行登录。</p><p><img src="https://static.aalmix.com/20201102173910.png" alt="image-20201102173622633"></p><h3 id="2-实现内网-web-端口转发，可以用于微信接口本地开发"><a href="#2-实现内网-web-端口转发，可以用于微信接口本地开发" class="headerlink" title="2.实现内网 web 端口转发，可以用于微信接口本地开发"></a>2.实现内网 web 端口转发，可以用于微信接口本地开发</h3><p>frps.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">token</span> = <span class="hljs-number">123456</span><br><span class="hljs-attr">vhost_http_port</span> = <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>frpc.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = x.x.x.x<br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">token</span> = <span class="hljs-number">123456</span><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">6000</span><br><span class="hljs-section">[mstsc]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">3389</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">7402</span><br><span class="hljs-section">[web]</span><br><span class="hljs-attr">type</span> = http<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">8078</span><br><span class="hljs-attr">custom_domains</span> = www.youdomain.com<br></code></pre></td></tr></table></figure><p>这里的配置文件多了一个 token 的配置，token 用于验证连接，只有服务器端和客户端的 token 相同才能正常访问,避免被别人恶意攻击。重新启动 frps 和 frpc，然后我们就可以通过 <a href="http://www.youdomain.com/">www.youdomain.com</a>:8080 访问 内网地址的 8078 端口了，8080 端口是 frps 中配置的 vhost_http_port 端口。</p><p><img src="https://static.aalmix.com/20201102173915.png" alt="image-20201102173744935"></p><p>**没有域名的配置 **</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># frps.ini</span><br>[common]<br>bind_addr = 0.0.0.0<br>bind_port = 7000<br>privilege_token = 12345678<br><br><br><span class="hljs-comment"># frpc.ini客户端配置</span><br>[common]<br>server_addr = 服务端IP<br>server_port = 7000<br>privilege_token = 12345678<br><br>[httpname]<br>type = tcp<br>local_port = 80<br>local_ip = 127.0.0.1<br>remote_port = 8080<br><br>通过 服务端IP:8080既可访问到对应穿透的服务<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p>官网说明文档 <a href="https://github.com/fatedier/frp/blob/master/README_zh.md">https://github.com/fatedier/frp/blob/master/README_zh.md</a></p></li><li><p>将 frp 注册为 windows 服务 <a href="https://www.cnblogs.com/mobaids/p/11567899.html">https://www.cnblogs.com/mobaids/p/11567899.html</a> 【测试通过】</p></li><li><p>frp 使用 nginx 配置多个 http 代理 <a href="https://github.com/fatedier/frp/issues/287">https://github.com/fatedier/frp/issues/287</a></p></li><li><p>没有域名的访问 web 服务的配置<a href="https://www.cnblogs.com/sanduzxcvbnm/p/8509150.html">https://www.cnblogs.com/sanduzxcvbnm/p/8509150.html</a> 【测试通过】</p></li><li><p>使用二级域名的方式访问多个 web 服务 <a href="https://blog.csdn.net/u012577474/article/details/99690716">https://blog.csdn.net/u012577474/article/details/99690716</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供</summary>
      
    
    
    
    
    <category term="frp" scheme="https://blog.aalmix.com/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>猎豹行动读书笔记</title>
    <link href="https://blog.aalmix.com/2020/10/01/%E7%8C%8E%E8%B1%B9%E8%A1%8C%E5%8A%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.aalmix.com/2020/10/01/%E7%8C%8E%E8%B1%B9%E8%A1%8C%E5%8A%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-01T02:37:09.000Z</published>
    <updated>2023-03-18T05:41:24.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传统模式的问题"><a href="#传统模式的问题" class="headerlink" title="传统模式的问题"></a>传统模式的问题</h2><p>瀑布模型对业务部门的痛点</p><ol><li>逾期交付</li><li>超支</li><li>看到成品时项目已经接近尾声</li><li>缺乏透明度，不知道具体进度</li><li>很难变更需求</li><li>最终开发的产品不是他们想要的</li><li>延误战机，丢失机场机会</li></ol><p>对IT部门的痛点：</p><ol><li>过度承诺</li><li>难以一次性消化所有需求</li><li>害怕需求变更</li><li>不断重做</li><li>后期压力大</li><li>加班</li></ol><p>分析造成这些痛点的原因：一个项目开始时，业务部门只会给IT部门需求概要和期望的交付日期，IT部门需要做评估和计划。而在项目开始的时候，只有预算和目标交付时间时确定的，还有其他因素都是不确定的，例如范围与具体需求，可能的需求变更，人员中途休假和离职，对现有系统的影响，服务器环境的搭建（需要什么配置，何时能到位）等。</p><p>瀑布模型的开发过程一般有需求分析，设计，编程，测试和发布几个阶段，每个阶段一环扣一环，设计，编程，测试都依赖于完整且稳定的需求，因此需求分析非常重要，但往往花大了大量的时间挖掘需求，却压缩了开发时间，形成矛盾。用户在看到成品前，可能都无法确定自己真正想要的是什么，需求变化是不可避免的，牵一发而动全身，导致IT人员普遍不喜欢需求变更，所以简单的说瀑布模型适合确定性非常搞的项目，但这样的项目凤毛麟角。</p><h2 id="什么是敏捷开发"><a href="#什么是敏捷开发" class="headerlink" title="什么是敏捷开发"></a>什么是敏捷开发</h2><p>敏捷所有的改变都是为了一件事，快速反馈！</p><p>敏捷开发有很多方法论，其中比较流行的有Scrum，极限编程，看板方法。<br>Scrum中的概念：<br><strong>Product Owner（PO）</strong>：用户&#x2F;客户&#x2F;业务的代言人，就是可以做出业务决策的人，在Scrum中，PO的角色非常重要，一个成功的敏捷项目背后一定有一个好的PO。<br><strong>Scrum Master</strong>：熟悉Scrum流程的人，指导和确保团队已Scrum的方式进行交付<br><strong>Sprint</strong>： 迭代，一个项目的交付由多个迭代构成。<br><strong>User Story</strong>：用户故事，具有业务价值的交付单位，一个项目是由很多用户故事构成的。<br><strong>Product Backlog</strong>:可以理解位项目的待办，由用户故事构成<br><strong>Sprint Backlog</strong>: Sprint待办，确定一个迭代中由哪些用户故事，确定本次迭代的开发范围</p><p>每个项目的交付由多个迭代构成，迭代的周期是固定的，通常是2-4个星期，不建议超过4个星期。</p><h2 id="如何启动敏捷开发，Scrum开发流程："><a href="#如何启动敏捷开发，Scrum开发流程：" class="headerlink" title="如何启动敏捷开发，Scrum开发流程："></a>如何启动敏捷开发，Scrum开发流程：</h2><ul><li>在每个Sprint开始的时候，PO和IT团队一起开Sprint计划会议，PO 对 Product Backlog 中的用户故事进行排序，选出最重要的用户故事。IT团队会对这些用户故事进行估算。</li><li>接下来IT团队围绕Sprint Backlog中的用户故事进行开发。IT团队每天组织一次站会，所有成员聚在一起，每个成员说一下“昨天做了什么，今天会做什么，昨天遇到了什么问题”，这是为了让整个团队了解进度，也是为了尽早地暴露问题并及时解决。一个问题越早解决成本越低。由于站会每天都要发生，因此这个会议建议控制在15~20分钟。团队规模也有要求，建议团队人数控制在7个人以内。如果项目比较大型，应该考虑把大型团队拆分成若干个小团队。小团队的沟通效率也远远比大型团队高。</li><li>在Sprint结束的时候，PO和IT团队又聚在一起开评审会议，IT团队向PO展示这个Sprint的交付，PO有任何反馈，甚至编程都可以定义成新的用户故事放到Product Backlog中重新排队，这也是敏捷应对需求变化的方法。这样缩短了反馈周期，可以帮助双方及时调整项目的方向，确保最终交付的正确性。</li><li>IT团队也可以在这个时候总结下这个迭代中哪些地方做的好，哪些地方可以做的更好，形成持续改善的机制。</li></ul><p><strong>敏捷宣言</strong></p><ul><li>个体的交互胜于过程与工具</li><li>可工作的软件胜于面面俱到的文档</li><li>与客户的协作甚于基于合同的谈判</li><li>短迭代开发，让PO更快，更早的看到成品，给与反馈</li><li>每日站会，每天都能看到进度和阻碍</li><li>回顾会议，每个迭代都要反思改进，形成持续改善的机制</li></ul><h2 id="实施敏捷开发的好处"><a href="#实施敏捷开发的好处" class="headerlink" title="实施敏捷开发的好处"></a>实施敏捷开发的好处</h2><p>对业务部门：</p><ol><li>不再需要一次性解释所有的需求</li><li>可以随时提出需求变更</li><li>进度透明</li><li>确保最重要的需求能在目标交付日期获得</li><li>确保得到正确的产品</li></ol><p>对IT部门：</p><ol><li>不再需要承诺一个未必能实现的计划</li><li>更早的开工和交付</li><li>为当前迭代进行更精确的计划</li><li>适应需求变化</li><li>适应不确定性</li><li>开发正确的产品</li><li>与业务人员的争执更少</li></ol><h2 id="敏捷与Devops有什么关联"><a href="#敏捷与Devops有什么关联" class="headerlink" title="敏捷与Devops有什么关联"></a>敏捷与Devops有什么关联</h2><p>敏捷打通了业务、开发、测试之间的墙，通过更紧密的沟通和交互实现更频繁的交付，然而开发团队和运维团队之间还有一堵墙，开发团队希望持续交付，运维团队希望稳定，DevOps就是要打破这最后一堵墙，实现开发与运维一体化和端对端的持续交付。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>Q: 假如项目在开始的时候，客户一定要我们承诺什么时候能交付，这个怎么解决？<br>A: 敏捷自己有一套估算和计划方法</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>JIRA: 项目与事务跟踪工具，被广泛应用于缺陷跟踪，客户服务，需求收集，敏捷管理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;传统模式的问题&quot;&gt;&lt;a href=&quot;#传统模式的问题&quot; class=&quot;headerlink&quot; title=&quot;传统模式的问题&quot;&gt;&lt;/a&gt;传统模式的问题&lt;/h2&gt;&lt;p&gt;瀑布模型对业务部门的痛点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逾期交付&lt;/li&gt;
&lt;li&gt;超支&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="https://blog.aalmix.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="敏捷" scheme="https://blog.aalmix.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
</feed>
